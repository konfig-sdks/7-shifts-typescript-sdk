/* tslint:disable */
/* eslint-disable */
/*
7shifts API

7shifts is a team management software designed for restaurants. We help managers and operators spend less time and effort scheduling their staff, reduce their monthly labor costs and improve team communication. The result is simplified team management, one shift at a time.

7shifts also offers free mobile apps (iOS and Android) allowing managers and employees to have everything at their fingertips.

Start your free trial or request a demo at www.7shifts.com.

The version of the OpenAPI document: 2023-05-01
Contact: api-support@7shifts.com

NOTE: This file is auto generated by Konfig (https://konfigthis.com).
*/

import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, isBrowser } from '../common';
import { setOAuthToObject } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { TimePunchesCreate400Response } from '../models';
// @ts-ignore
import { TimePunchesCreate401Response } from '../models';
// @ts-ignore
import { TimePunchesCreate403Response } from '../models';
// @ts-ignore
import { TimePunchesCreate404Response } from '../models';
// @ts-ignore
import { TimePunchesCreate422Response } from '../models';
// @ts-ignore
import { TimePunchesCreate500Response } from '../models';
// @ts-ignore
import { TimePunchesCreateRequest } from '../models';
// @ts-ignore
import { TimePunchesCreateRequestBreaksInner } from '../models';
// @ts-ignore
import { TimePunchesCreateResponse } from '../models';
// @ts-ignore
import { TimePunchesDeleteById403Response } from '../models';
// @ts-ignore
import { TimePunchesDeleteById404Response } from '../models';
// @ts-ignore
import { TimePunchesDeleteById500Response } from '../models';
// @ts-ignore
import { TimePunchesDeleteByIdResponse } from '../models';
// @ts-ignore
import { TimePunchesGetTimePunch401Response } from '../models';
// @ts-ignore
import { TimePunchesGetTimePunch403Response } from '../models';
// @ts-ignore
import { TimePunchesGetTimePunch404Response } from '../models';
// @ts-ignore
import { TimePunchesGetTimePunch500Response } from '../models';
// @ts-ignore
import { TimePunchesGetTimePunchResponse } from '../models';
// @ts-ignore
import { TimePunchesList401Response } from '../models';
// @ts-ignore
import { TimePunchesList403Response } from '../models';
// @ts-ignore
import { TimePunchesList422Response } from '../models';
// @ts-ignore
import { TimePunchesList500Response } from '../models';
// @ts-ignore
import { TimePunchesListResponse } from '../models';
// @ts-ignore
import { TimePunchesUpdateById400Response } from '../models';
// @ts-ignore
import { TimePunchesUpdateById401Response } from '../models';
// @ts-ignore
import { TimePunchesUpdateById403Response } from '../models';
// @ts-ignore
import { TimePunchesUpdateById404Response } from '../models';
// @ts-ignore
import { TimePunchesUpdateById422Response } from '../models';
// @ts-ignore
import { TimePunchesUpdateById500Response } from '../models';
// @ts-ignore
import { TimePunchesUpdateByIdRequest } from '../models';
// @ts-ignore
import { TimePunchesUpdateByIdRequestBreaksInner } from '../models';
// @ts-ignore
import { TimePunchesUpdateByIdResponse } from '../models';
import { paginate } from "../pagination/paginate";
import type * as buffer from "buffer"
import { requestBeforeHook } from '../requestBeforeHook';
/**
 * TimePunchesApi - axios parameter creator
 * @export
 */
export const TimePunchesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Time Punch
         * @param {number} companyId The company id
         * @param {TimePunchesCreateRequest} timePunchesCreateRequest 
         * @param {string} [xApiVersion] 7shifts API version
         * @param {string} [xCompanyGuid] Company GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (companyId: number, timePunchesCreateRequest: TimePunchesCreateRequest, xApiVersion?: string, xCompanyGuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('create', 'companyId', companyId)
            // verify required parameter 'timePunchesCreateRequest' is not null or undefined
            assertParamExists('create', 'timePunchesCreateRequest', timePunchesCreateRequest)
            const localVarPath = `/v2/company/{company_id}/time_punches`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId !== undefined ? companyId : `-company_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication cookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "7session", configuration})
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }

            if (xCompanyGuid != null) {
                localVarHeaderParameter['x-company-guid'] = String(xCompanyGuid);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: timePunchesCreateRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/company/{company_id}/time_punches',
                httpMethod: 'POST'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(timePunchesCreateRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete Time Punch
         * @param {number} companyId Company ID
         * @param {number} timePunchId Time punch ID
         * @param {string} [xApiVersion] 7shifts API version
         * @param {string} [xCompanyGuid] Company GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById: async (companyId: number, timePunchId: number, xApiVersion?: string, xCompanyGuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('deleteById', 'companyId', companyId)
            // verify required parameter 'timePunchId' is not null or undefined
            assertParamExists('deleteById', 'timePunchId', timePunchId)
            const localVarPath = `/v2/company/{company_id}/time_punches/{time_punch_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId !== undefined ? companyId : `-company_id-`)))
                .replace(`{${"time_punch_id"}}`, encodeURIComponent(String(timePunchId !== undefined ? timePunchId : `-time_punch_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication cookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "7session", configuration})
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }

            if (xCompanyGuid != null) {
                localVarHeaderParameter['x-company-guid'] = String(xCompanyGuid);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/company/{company_id}/time_punches/{time_punch_id}',
                httpMethod: 'DELETE'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve Time Punch
         * @param {number} companyId Company ID
         * @param {number} timePunchId Time punch ID
         * @param {string} [xApiVersion] 7shifts API version
         * @param {string} [xCompanyGuid] Company GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimePunch: async (companyId: number, timePunchId: number, xApiVersion?: string, xCompanyGuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('getTimePunch', 'companyId', companyId)
            // verify required parameter 'timePunchId' is not null or undefined
            assertParamExists('getTimePunch', 'timePunchId', timePunchId)
            const localVarPath = `/v2/company/{company_id}/time_punches/{time_punch_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId !== undefined ? companyId : `-company_id-`)))
                .replace(`{${"time_punch_id"}}`, encodeURIComponent(String(timePunchId !== undefined ? timePunchId : `-time_punch_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication cookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "7session", configuration})
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }

            if (xCompanyGuid != null) {
                localVarHeaderParameter['x-company-guid'] = String(xCompanyGuid);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/company/{company_id}/time_punches/{time_punch_id}',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List Time Punches
         * @param {number} companyId Company ID
         * @param {string} [xApiVersion] 7shifts API version
         * @param {string} [xCompanyGuid] Company GUID
         * @param {number} [locationId] Location ID
         * @param {number} [departmentId] Department ID
         * @param {number} [roleId] Role ID
         * @param {number} [userId] User ID
         * @param {boolean} [approved] Returns time punches that have been approved. Default null, returns both approved and unapproved punches. If true returns only approved punches. If false returns only unapproved punches.
         * @param {number} [limit] The limit of results that will be returned.
         * @param {string} [modifiedSince] Return time punches that have been modified after the specified date time. UTC in ISO8601 Format
         * @param {string} [clockedInLte] Return time punches with clocked in before or on the specified date.  UTC in ISO8601 format
         * @param {string} [clockedInGte] Return time punches with clocked in after or on the specified date.  UTC in ISO8601 format
         * @param {string} [clockedOutLte] Return time punches with clocked out before or on the specified date.  UTC in ISO8601 format
         * @param {string} [clockedOutGte] Return time punches with clocked out after or on the specified date.  UTC in ISO8601 format
         * @param {boolean} [includeDeleted] Deprecated, see \&#39;deleted\&#39;
         * @param {boolean} [deleted] Returns punches filtered by deleted status.  Default false, returns undeleted punches. If true returns only deleted punches. if value is null then returns both deleted and undeleted punches.
         * @param {boolean} [localizeSearchTime] If true, convert any date ranges to consider the local timezone of the punches.  If false, date ranges will be in UTC
         * @param {string} [cursor] Cursor for the next or previous page of results.
         * @param {string} [sortBy] The name of the field and direction you want the results ordered by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list: async (companyId: number, xApiVersion?: string, xCompanyGuid?: string, locationId?: number, departmentId?: number, roleId?: number, userId?: number, approved?: boolean, limit?: number, modifiedSince?: string, clockedInLte?: string, clockedInGte?: string, clockedOutLte?: string, clockedOutGte?: string, includeDeleted?: boolean, deleted?: boolean, localizeSearchTime?: boolean, cursor?: string, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('list', 'companyId', companyId)
            const localVarPath = `/v2/company/{company_id}/time_punches`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId !== undefined ? companyId : `-company_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication cookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "7session", configuration})
            if (locationId !== undefined) {
                localVarQueryParameter['location_id'] = locationId;
            }

            if (departmentId !== undefined) {
                localVarQueryParameter['department_id'] = departmentId;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (approved !== undefined) {
                localVarQueryParameter['approved'] = approved;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (modifiedSince !== undefined) {
                localVarQueryParameter['modified_since'] = (modifiedSince as any instanceof Date) ?
                    (modifiedSince as any).toISOString() :
                    modifiedSince;
            }

            if (clockedInLte !== undefined) {
                localVarQueryParameter['clocked_in[lte]'] = (clockedInLte as any instanceof Date) ?
                    (clockedInLte as any).toISOString() :
                    clockedInLte;
            }

            if (clockedInGte !== undefined) {
                localVarQueryParameter['clocked_in[gte]'] = (clockedInGte as any instanceof Date) ?
                    (clockedInGte as any).toISOString() :
                    clockedInGte;
            }

            if (clockedOutLte !== undefined) {
                localVarQueryParameter['clocked_out[lte]'] = (clockedOutLte as any instanceof Date) ?
                    (clockedOutLte as any).toISOString() :
                    clockedOutLte;
            }

            if (clockedOutGte !== undefined) {
                localVarQueryParameter['clocked_out[gte]'] = (clockedOutGte as any instanceof Date) ?
                    (clockedOutGte as any).toISOString() :
                    clockedOutGte;
            }

            if (includeDeleted !== undefined) {
                localVarQueryParameter['include_deleted'] = includeDeleted;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (localizeSearchTime !== undefined) {
                localVarQueryParameter['localize_search_time'] = localizeSearchTime;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }

            if (xCompanyGuid != null) {
                localVarHeaderParameter['x-company-guid'] = String(xCompanyGuid);
            }


    
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/company/{company_id}/time_punches',
                httpMethod: 'GET'
            });

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update Time Punch
         * @param {number} companyId Company id
         * @param {number} timePunchId Time punch id
         * @param {TimePunchesUpdateByIdRequest} timePunchesUpdateByIdRequest 
         * @param {string} [xApiVersion] 7shifts API version
         * @param {string} [xCompanyGuid] Company GUID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateById: async (companyId: number, timePunchId: number, timePunchesUpdateByIdRequest: TimePunchesUpdateByIdRequest, xApiVersion?: string, xCompanyGuid?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'companyId' is not null or undefined
            assertParamExists('updateById', 'companyId', companyId)
            // verify required parameter 'timePunchId' is not null or undefined
            assertParamExists('updateById', 'timePunchId', timePunchId)
            // verify required parameter 'timePunchesUpdateByIdRequest' is not null or undefined
            assertParamExists('updateById', 'timePunchesUpdateByIdRequest', timePunchesUpdateByIdRequest)
            const localVarPath = `/v2/company/{company_id}/time_punches/{time_punch_id}`
                .replace(`{${"company_id"}}`, encodeURIComponent(String(companyId !== undefined ? companyId : `-company_id-`)))
                .replace(`{${"time_punch_id"}}`, encodeURIComponent(String(timePunchId !== undefined ? timePunchId : `-time_punch_id-`)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions: AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = configuration && !isBrowser() ? { "User-Agent": configuration.userAgent } : {} as any;
            const localVarQueryParameter = {} as any;

            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication OAuth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2", [], configuration)
            // authentication cookieAuth required
            await setApiKeyToObject({object: localVarHeaderParameter, type: "Cookie", key: "Cookie", keyParamName: "7session", configuration})
            if (xApiVersion != null) {
                localVarHeaderParameter['x-api-version'] = String(xApiVersion);
            }

            if (xCompanyGuid != null) {
                localVarHeaderParameter['x-company-guid'] = String(xCompanyGuid);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';


            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            requestBeforeHook({
                requestBody: timePunchesUpdateByIdRequest,
                queryParameters: localVarQueryParameter,
                requestConfig: localVarRequestOptions,
                path: localVarPath,
                configuration,
                pathTemplate: '/v2/company/{company_id}/time_punches/{time_punch_id}',
                httpMethod: 'PUT'
            });
            localVarRequestOptions.data = serializeDataIfNeeded(timePunchesUpdateByIdRequest, localVarRequestOptions, configuration)

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TimePunchesApi - functional programming interface
 * @export
 */
export const TimePunchesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TimePunchesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Time Punch
         * @param {TimePunchesApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(requestParameters: TimePunchesApiCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimePunchesCreateResponse>> {
            const timePunchesCreateRequest: TimePunchesCreateRequest = {
                location_id: requestParameters.location_id,
                department_id: requestParameters.department_id,
                user_id: requestParameters.user_id,
                role_id: requestParameters.role_id,
                clocked_in: requestParameters.clocked_in,
                clocked_out: requestParameters.clocked_out,
                notes: requestParameters.notes,
                tips: requestParameters.tips,
                breaks: requestParameters.breaks
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(requestParameters.companyId, timePunchesCreateRequest, requestParameters.xApiVersion, requestParameters.xCompanyGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete Time Punch
         * @param {TimePunchesApiDeleteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteById(requestParameters: TimePunchesApiDeleteByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteById(requestParameters.companyId, requestParameters.timePunchId, requestParameters.xApiVersion, requestParameters.xCompanyGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve Time Punch
         * @param {TimePunchesApiGetTimePunchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimePunch(requestParameters: TimePunchesApiGetTimePunchRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimePunchesGetTimePunchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTimePunch(requestParameters.companyId, requestParameters.timePunchId, requestParameters.xApiVersion, requestParameters.xCompanyGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary List Time Punches
         * @param {TimePunchesApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async list(requestParameters: TimePunchesApiListRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimePunchesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.list(requestParameters.companyId, requestParameters.xApiVersion, requestParameters.xCompanyGuid, requestParameters.locationId, requestParameters.departmentId, requestParameters.roleId, requestParameters.userId, requestParameters.approved, requestParameters.limit, requestParameters.modifiedSince, requestParameters.clockedInLte, requestParameters.clockedInGte, requestParameters.clockedOutLte, requestParameters.clockedOutGte, requestParameters.includeDeleted, requestParameters.deleted, requestParameters.localizeSearchTime, requestParameters.cursor, requestParameters.sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update Time Punch
         * @param {TimePunchesApiUpdateByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateById(requestParameters: TimePunchesApiUpdateByIdRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TimePunchesUpdateByIdResponse>> {
            const timePunchesUpdateByIdRequest: TimePunchesUpdateByIdRequest = {
                department_id: requestParameters.department_id,
                role_id: requestParameters.role_id,
                clocked_in: requestParameters.clocked_in,
                clocked_out: requestParameters.clocked_out,
                notes: requestParameters.notes,
                tips: requestParameters.tips,
                breaks: requestParameters.breaks
            };
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateById(requestParameters.companyId, requestParameters.timePunchId, timePunchesUpdateByIdRequest, requestParameters.xApiVersion, requestParameters.xCompanyGuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TimePunchesApi - factory interface
 * @export
 */
export const TimePunchesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TimePunchesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Time Punch
         * @param {TimePunchesApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: TimePunchesApiCreateRequest, options?: AxiosRequestConfig): AxiosPromise<TimePunchesCreateResponse> {
            return localVarFp.create(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete Time Punch
         * @param {TimePunchesApiDeleteByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteById(requestParameters: TimePunchesApiDeleteByIdRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteById(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve Time Punch
         * @param {TimePunchesApiGetTimePunchRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimePunch(requestParameters: TimePunchesApiGetTimePunchRequest, options?: AxiosRequestConfig): AxiosPromise<TimePunchesGetTimePunchResponse> {
            return localVarFp.getTimePunch(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List Time Punches
         * @param {TimePunchesApiListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        list(requestParameters: TimePunchesApiListRequest, options?: AxiosRequestConfig): AxiosPromise<TimePunchesListResponse> {
            return localVarFp.list(requestParameters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update Time Punch
         * @param {TimePunchesApiUpdateByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateById(requestParameters: TimePunchesApiUpdateByIdRequest, options?: AxiosRequestConfig): AxiosPromise<TimePunchesUpdateByIdResponse> {
            return localVarFp.updateById(requestParameters, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create operation in TimePunchesApi.
 * @export
 * @interface TimePunchesApiCreateRequest
 */
export type TimePunchesApiCreateRequest = {
    
    /**
    * The company id
    * @type {number}
    * @memberof TimePunchesApiCreate
    */
    readonly companyId: number
    
    /**
    * 7shifts API version
    * @type {string}
    * @memberof TimePunchesApiCreate
    */
    readonly xApiVersion?: string
    
    /**
    * Company GUID
    * @type {string}
    * @memberof TimePunchesApiCreate
    */
    readonly xCompanyGuid?: string
    
} & TimePunchesCreateRequest

/**
 * Request parameters for deleteById operation in TimePunchesApi.
 * @export
 * @interface TimePunchesApiDeleteByIdRequest
 */
export type TimePunchesApiDeleteByIdRequest = {
    
    /**
    * Company ID
    * @type {number}
    * @memberof TimePunchesApiDeleteById
    */
    readonly companyId: number
    
    /**
    * Time punch ID
    * @type {number}
    * @memberof TimePunchesApiDeleteById
    */
    readonly timePunchId: number
    
    /**
    * 7shifts API version
    * @type {string}
    * @memberof TimePunchesApiDeleteById
    */
    readonly xApiVersion?: string
    
    /**
    * Company GUID
    * @type {string}
    * @memberof TimePunchesApiDeleteById
    */
    readonly xCompanyGuid?: string
    
}

/**
 * Request parameters for getTimePunch operation in TimePunchesApi.
 * @export
 * @interface TimePunchesApiGetTimePunchRequest
 */
export type TimePunchesApiGetTimePunchRequest = {
    
    /**
    * Company ID
    * @type {number}
    * @memberof TimePunchesApiGetTimePunch
    */
    readonly companyId: number
    
    /**
    * Time punch ID
    * @type {number}
    * @memberof TimePunchesApiGetTimePunch
    */
    readonly timePunchId: number
    
    /**
    * 7shifts API version
    * @type {string}
    * @memberof TimePunchesApiGetTimePunch
    */
    readonly xApiVersion?: string
    
    /**
    * Company GUID
    * @type {string}
    * @memberof TimePunchesApiGetTimePunch
    */
    readonly xCompanyGuid?: string
    
}

/**
 * Request parameters for list operation in TimePunchesApi.
 * @export
 * @interface TimePunchesApiListRequest
 */
export type TimePunchesApiListRequest = {
    
    /**
    * Company ID
    * @type {number}
    * @memberof TimePunchesApiList
    */
    readonly companyId: number
    
    /**
    * 7shifts API version
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly xApiVersion?: string
    
    /**
    * Company GUID
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly xCompanyGuid?: string
    
    /**
    * Location ID
    * @type {number}
    * @memberof TimePunchesApiList
    */
    readonly locationId?: number
    
    /**
    * Department ID
    * @type {number}
    * @memberof TimePunchesApiList
    */
    readonly departmentId?: number
    
    /**
    * Role ID
    * @type {number}
    * @memberof TimePunchesApiList
    */
    readonly roleId?: number
    
    /**
    * User ID
    * @type {number}
    * @memberof TimePunchesApiList
    */
    readonly userId?: number
    
    /**
    * Returns time punches that have been approved. Default null, returns both approved and unapproved punches. If true returns only approved punches. If false returns only unapproved punches.
    * @type {boolean}
    * @memberof TimePunchesApiList
    */
    readonly approved?: boolean
    
    /**
    * The limit of results that will be returned.
    * @type {number}
    * @memberof TimePunchesApiList
    */
    readonly limit?: number
    
    /**
    * Return time punches that have been modified after the specified date time. UTC in ISO8601 Format
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly modifiedSince?: string
    
    /**
    * Return time punches with clocked in before or on the specified date.  UTC in ISO8601 format
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly clockedInLte?: string
    
    /**
    * Return time punches with clocked in after or on the specified date.  UTC in ISO8601 format
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly clockedInGte?: string
    
    /**
    * Return time punches with clocked out before or on the specified date.  UTC in ISO8601 format
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly clockedOutLte?: string
    
    /**
    * Return time punches with clocked out after or on the specified date.  UTC in ISO8601 format
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly clockedOutGte?: string
    
    /**
    * Deprecated, see \'deleted\'
    * @type {boolean}
    * @memberof TimePunchesApiList
    */
    readonly includeDeleted?: boolean
    
    /**
    * Returns punches filtered by deleted status.  Default false, returns undeleted punches. If true returns only deleted punches. if value is null then returns both deleted and undeleted punches.
    * @type {boolean}
    * @memberof TimePunchesApiList
    */
    readonly deleted?: boolean
    
    /**
    * If true, convert any date ranges to consider the local timezone of the punches.  If false, date ranges will be in UTC
    * @type {boolean}
    * @memberof TimePunchesApiList
    */
    readonly localizeSearchTime?: boolean
    
    /**
    * Cursor for the next or previous page of results.
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly cursor?: string
    
    /**
    * The name of the field and direction you want the results ordered by.
    * @type {string}
    * @memberof TimePunchesApiList
    */
    readonly sortBy?: string
    
}

/**
 * Request parameters for updateById operation in TimePunchesApi.
 * @export
 * @interface TimePunchesApiUpdateByIdRequest
 */
export type TimePunchesApiUpdateByIdRequest = {
    
    /**
    * Company id
    * @type {number}
    * @memberof TimePunchesApiUpdateById
    */
    readonly companyId: number
    
    /**
    * Time punch id
    * @type {number}
    * @memberof TimePunchesApiUpdateById
    */
    readonly timePunchId: number
    
    /**
    * 7shifts API version
    * @type {string}
    * @memberof TimePunchesApiUpdateById
    */
    readonly xApiVersion?: string
    
    /**
    * Company GUID
    * @type {string}
    * @memberof TimePunchesApiUpdateById
    */
    readonly xCompanyGuid?: string
    
} & TimePunchesUpdateByIdRequest

/**
 * TimePunchesApiGenerated - object-oriented interface
 * @export
 * @class TimePunchesApiGenerated
 * @extends {BaseAPI}
 */
export class TimePunchesApiGenerated extends BaseAPI {
    /**
     * 
     * @summary Create Time Punch
     * @param {TimePunchesApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePunchesApiGenerated
     */
    public create(requestParameters: TimePunchesApiCreateRequest, options?: AxiosRequestConfig) {
        return TimePunchesApiFp(this.configuration).create(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete Time Punch
     * @param {TimePunchesApiDeleteByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePunchesApiGenerated
     */
    public deleteById(requestParameters: TimePunchesApiDeleteByIdRequest, options?: AxiosRequestConfig) {
        return TimePunchesApiFp(this.configuration).deleteById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve Time Punch
     * @param {TimePunchesApiGetTimePunchRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePunchesApiGenerated
     */
    public getTimePunch(requestParameters: TimePunchesApiGetTimePunchRequest, options?: AxiosRequestConfig) {
        return TimePunchesApiFp(this.configuration).getTimePunch(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List Time Punches
     * @param {TimePunchesApiListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePunchesApiGenerated
     */
    public list(requestParameters: TimePunchesApiListRequest, options?: AxiosRequestConfig) {
        return TimePunchesApiFp(this.configuration).list(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update Time Punch
     * @param {TimePunchesApiUpdateByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TimePunchesApiGenerated
     */
    public updateById(requestParameters: TimePunchesApiUpdateByIdRequest, options?: AxiosRequestConfig) {
        return TimePunchesApiFp(this.configuration).updateById(requestParameters, options).then((request) => request(this.axios, this.basePath));
    }
}
